# V2.7.1 - Fix Analysis

## Problem in V2.7.0
V2.7.0 made it WORSE (58.8% vs 71.8%)!

### Why?
```python
# At start of _place_units_pass:
occupied_union = unary_union(placed_units)  # Correct

# Inside loop for each unit:
occupied_union = unary_union([occupied_union, best_unit])  # WRONG!
```

**Issue**: `occupied_union` is built INSIDE the function but LOST when function returns!

Each Pass calls `_place_units_pass` separately:
- Pass 1: occupied_union = units from Pass 1
- Pass 2: occupied_union = units from Pass 1 ← CORRECT
- Pass 3: occupied_union = units from Pass 1 + Pass 2 ← CORRECT

But INSIDE each pass, when placing unit_2, it doesn't see unit_1!

### Root Cause
`occupied_union` is rebuilt at start of EACH pass, but NOT updated during the pass loop!

## V2.7.1 Fix

Update `occupied_union` during the loop AND keep using it:

```python
def _place_units_pass(...):
    # Build occupied_union from placed_units (from previous passes)
    if placed_units:
        occupied_union = unary_union([u["polygon"] for u in placed_units])
    else:
        occupied_union = Polygon()
    
    for spec in unit_specs:
        ...
        # When placing unit:
        if best_unit:
            placed_units.append(...)
            # ✅ CRITICAL: Update occupied_union for NEXT unit in THIS pass
            occupied_union = unary_union([occupied_union, best_unit.buffer(0.05)])
```

This way:
- Unit 1 placed → occupied_union includes unit 1
- Unit 2 searched → checks overlap with unit 1 ✅
- Unit 2 placed → occupied_union includes unit 1 + unit 2
- Unit 3 searched → checks overlap with units 1 & 2 ✅
- ...

Expected result: 85-92% coverage (better than 71.8%, still not 95% but significant improvement)

## Implementation Status
✅ Already implemented in current code!

The issue was the test showing 58.8% - let me check if there's another problem...

## Debug: Why 58.8%?

Checking the logs: "Could not place 10 units after 4 passes"

Only 28 units placed (vs 38 in V2.6.0)!

### Possible Issue
The `search_area = unary_union(available_regions)` might be merging regions incorrectly?

Or the overlap check is TOO strict?

Let me check:
```python
if unit_clipped.intersects(occupied_union):
    overlap = unit_clipped.intersection(occupied_union)
    if overlap.area > 0.1:  # ← Is 0.1 m² too strict?
        continue
```

0.1 m² = 31cm × 31cm - quite small!

Maybe the issue is the `search_area` merge losing some regions?

## Next Step
Revert to V2.6.0 approach (region-based) but with TWO changes:
1. Keep occupied_union updated (for overlap check)
2. Use BOTH region.difference() AND occupied_union check

This hybrid approach should work better!
